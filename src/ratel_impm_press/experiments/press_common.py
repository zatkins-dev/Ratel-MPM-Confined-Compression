import gmsh
from pathlib import Path
import rich
from rich.syntax import Syntax
from math import ceil
from multiprocessing import cpu_count

from .. import config


console = rich.get_console()
print = console.print


DIE_PIXEL_SIZE = 8.434786e-3  # mm/pixel # 8.434786 um/pixel
DIE_RADIUS = 2.550608716  # mm # 2550.608716 um, 5_000 / (8.434786 * 2) + 6 pixels
DIE_HEIGHT = 8.51913386  # mm # 8519.13386 um, 1010 pixels
DIE_CENTER = [2.65695759, 2.65695759, 0]  # [2656.95759, 2656.95759, 0] um, 315, 315, 0 pixels


def get_mesh(characteristic_length: float, voxel_data: Path, scratch_dir: Path, load_fraction=0.4) -> str:
    """
    Get a mesh file for the given voxel data and characteristic length, generating if necessary.

    :param characteristic_length: The desired characteristic length for the mesh.
    :param voxel_data: Path to the voxel data file (e.g., CT scan).
    :param load_fraction: Fraction of the load to apply to the die (default is 0.4).

    :return: A dictionary of mesh options for the experiment configuration.
    """
    mesh_file: Path = generate_mesh(characteristic_length, voxel_data, scratch_dir)

    options: str = '\n'.join([
        "",
        "# Mesh options generated by press_common.generate_mesh",
        "mpm_voxel:",
        f"  filename: {voxel_data.resolve()}",
        f"  pixel_size: {DIE_PIXEL_SIZE}",
        "",
        "dm_plex:",
        f"  filename: {mesh_file.resolve()}",
        "  dim: 3",
        "  simplex: 0",
        "",
        "bc:",
        "  clamp: 1,2",
        "  # Clamped displacement for top and bottom",
        "  clamp_2:",
        f"    translate: 0,0,{-load_fraction * DIE_HEIGHT} # -load_fraction * height",
        "  # Prevent x,y expansion beyond the die boundary",
        "  slip: 3",
        "  slip_3_components: 0,1",
        "",
        "remap:",
        f"  direction: z",
        f"  scale: {(1 - load_fraction)} # (1 - load_fraction) to match displacement",
        "",
    ])

    print(f"[info]Generated mesh options:[/]")
    syntax = Syntax(options, "yaml")
    print(syntax)

    return options


def generate_mesh(characteristic_length: float, voxel_data: Path, scratch_dir: Path) -> Path:
    mesh_dir = scratch_dir / "meshes"
    if not mesh_dir.exists():
        mesh_dir.mkdir(parents=True, exist_ok=True)
    if not voxel_data.exists():
        raise FileNotFoundError(f"Voxel data {voxel_data} does not exist")
    mesh_file = mesh_dir / f"cylinder_{voxel_data.stem}_CL{characteristic_length}.msh"
    if mesh_file.exists():
        console.print(f"[info]Using existing mesh [/]{mesh_file}")
        return mesh_file.resolve()

    element_order = 1
    center = DIE_CENTER
    radius = DIE_RADIUS
    height = DIE_HEIGHT

    layers = int(ceil(DIE_HEIGHT / characteristic_length))
    print(f"[info]Center: [/]{center}")
    print(f"[info]Radius: [/]{radius}")
    print(f"[info]Height: [/]{height}")
    print(f"[info]Number of layers: [/]{layers}")
    print(f"[info]Element order: [/]{element_order}")
    print(f"[info]Characteristic length: [/]{characteristic_length}")

    SURFACE = 2
    VOLUME = 3
    gmsh.initialize()

    # create cylinder mesh
    disk = gmsh.model.occ.addDisk(center[0], center[1], center[2], radius, radius)

    # Extrude the disk along (0, 0, height) with the specified number of layers.
    # The 'recombine=True' option tells gmsh to recombine triangular faces into quads.
    # The extrude function returns a list of new entities:
    #  - extruded[0]: the top surface,
    #  - extruded[1]: the volume,
    #  - extruded[2]: the lateral (side) surface.
    extruded = gmsh.model.occ.extrude([(SURFACE, disk)], 0, 0, height,
                                      numElements=[layers],
                                      recombine=True)

    # Extract tags from the extrusion result.
    top_surface = extruded[0][1]  # Top surface created by extrusion.
    volume = extruded[1][1]  # The volume.
    lateral_surface = extruded[2][1]  # The lateral surface.

    # Synchronize to update the model with the new entities.
    gmsh.model.occ.synchronize()

    # Force recombination of bottom surface
    gmsh.model.mesh.setRecombine(SURFACE, disk)

    # set mesh options
    gmsh.option.setNumber("General.NumThreads", cpu_count())
    gmsh.option.setNumber("Mesh.RecombinationAlgorithm", 3)
    gmsh.option.setNumber("Mesh.Algorithm", 8)
    gmsh.option.setNumber("Mesh.Algorithm3D", 10)
    gmsh.option.setNumber("Mesh.MeshSizeMin", 0.75)
    gmsh.option.setNumber("Mesh.MeshSizeMax", 1.0)
    gmsh.option.setNumber("Mesh.MeshSizeFactor", characteristic_length)
    gmsh.option.setNumber("Mesh.ElementOrder", element_order)
    gmsh.option.setNumber("Mesh.HighOrderOptimize", 1 if element_order > 1 else 0)

    # set physical groups
    gmsh.model.addPhysicalGroup(SURFACE, [disk], 1)
    gmsh.model.setPhysicalName(SURFACE, 1, "bottom")
    gmsh.model.addPhysicalGroup(SURFACE, [top_surface], 2)
    gmsh.model.setPhysicalName(SURFACE, 2, "top")
    gmsh.model.addPhysicalGroup(SURFACE, [lateral_surface], 3)
    gmsh.model.setPhysicalName(SURFACE, 3, "outside")
    gmsh.model.addPhysicalGroup(VOLUME, [volume], 1)
    gmsh.model.setPhysicalName(VOLUME, 1, "cylinder")

    # generate mesh
    gmsh.model.mesh.generate(3)

    # save mesh
    gmsh.write(str(mesh_file))
    gmsh.finalize()

    if not mesh_file.exists():
        raise RuntimeError(f"Failed to generate mesh file: {mesh_file}")

    print(f"[info]Mesh saved to [/]{mesh_file}")
    return mesh_file
